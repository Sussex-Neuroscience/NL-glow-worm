---
title: "Trackball_Calibration"
author: "Sofia Fernandes"
date: "13/10/2021"
output: html_document
---

```{r libraries and global variables, echo=FALSE, message=FALSE, warning=FALSE}

library(dplyr)
library(grid)
library(gridExtra)
library(ggpubr)
library(tidyverse)
library(tidyr)
library(lubridate)
library(ggplot2)
library(REdaS)
library(flextable)


# ggplot theme
theme <- theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        text = element_text(size=12),
        axis.text = element_text(size=10),
        legend.position = "none")


# Ball radius and perimeter at equator
ball_rad <- 25 # in mm
real_distance <- 15*(2*pi*ball_rad)

```

## Stepper motor program

The calibration was performed using a stepper motor, controlled by an Arduino Uno. A custom 3D printed ball, of the same diameter of the polystyrene ball (5 cm), was attached to the motor and positioned on top of the trackball support. 

The motor and ball were aligned with the mice to create a fictive reading for:

- rotation on top of the ball;

- translation forward (axis between the two mice);

- translation to the left (aligned with the mouse on the right);

- translation to the right (aligned with the mouse on the left).

The motor and ball rotated 360 degrees 15 times, each time with a different speeds, for each of the fictive readings.

## Variables

### Raw variables from the optical mice

The optical mice (Logitech M500) comprise an infrared LED, an image acquisition system (IAS) and a digital signal processor (DSP). The infrared LED light projected onto the trackball surface bounces back and is captured by the IAS, which consists in a sensor that records, in this case, around 60 images per second. As the ball near the mouse moves, these images change and this change is processed by the DPS in order to determine the direction and magnitude of the movement. Thus, the raw data obtained from the optical mice, recorded by the Arduino Due and Bonsai are:

- **x displacement:** specifies the relative change in pixels (dots/counts) between the current and previous frames, in the horizontal axis;

- **y displacement:** specifies the relative change in pixels (dots/counts) between the current and previous frames,in the vertical axis;

- **Time:** number of microseconds that have passed from the moment the program was uploaded into Arduino.

These raw values are essentially distances, in pixel units, and each frame has an associated time.

### Specific experimental variables

The variable time was normalized to start at zero, converted to seconds (not shown), and used for merging the the data from the two mice to the nearest value. The time difference between frames calculated:

- **Time difference:** time difference between the current frame and the previous. 

For this particular set-up, the insect is tethered on top of the trackball facing a particular direction. As the animal turns, the ball rotates underneath it and this movement is captured by changes in the horizontal axis of the optical mice sensors. If the animal turns 360 degrees, the ball moves the correspondent value on the opposite direction. Thus, the x displacement values, in pixel units, correspond to the full perimeter of the ball at the equator level, at which the sensors are placed.

The variables calculated from the x displacement were:

- **Rotation linear displacement:** the negative of the mean x displacement value of the two mice;

- **Angular displacement:** Rotation linear displacement divided by the ball radius and multiplied by 180/pi to obtain this angle in degrees (this also corresponds to instant heading or facing angle);

- **Cumulative angular displacement:** sum of angular displacement of current and all previous frames;

- **Rotation linear velocity:** Rotation linear displacement divided by the time difference;

- **Angular velocity:** angular displacement divided by the time difference.

As the insect walks forwards on top of the ball, the movement is captured by the changed in the vertical axis of the optical mice sensors. Because the mice were orthogonal to each other, the y displacement from one mouse (the left) was taken as x and the y displacement from the other mouse as y and the forward velocity calculated as the hypotenuse between the two sides. Either mouse's y displacement could correspond to x or y.

The variables calculated from the y displacement were:

- **Forward displacement:** the squared root of the sum of the square of the y displacement from one mouse and the square of the y displacement of the other;

- **Cumulative forward displacement:** sum of forward displacement of current and all previous frames;

- **Forward velocity:** forward displacement divided by the time difference.

Lastly, the error between the two mice was calculated as the difference between their x displacement values, which should be the same if no error occurred.

```{r add time stamp numeric, echo=FALSE, message=FALSE, warning=FALSE}

# RUN ONLY ONCE: This normalizes the time to start at 0 us and adds it to the initial data file.

# Set working directory
#workdir_path <- "C:/Users/asd27/Desktop/Trackball calibration/Calibration_15Rot_difSpeed/R"
#setwd(workdir_path)

# List of files in working directory
#file_list = list.files(workdir_path, pattern = ".csv")

# Add time normalized to files
#for(i in 1:length(file_list)){

#  file_path <- paste0(workdir_path,"/", file_list[[i]])
  
#  file <- read.csv(file_path, header = TRUE)

#  file <- file %>% 
#            mutate(Time_normalized = Time - min(Time),
#                   Time_normalized_seconds = Time_normalized * 10^(-6)) 
  
#  file_name <- gsub('.csv','', file_list[i])
#  write.csv(file, paste0(file_name, ".csv"))
  
#}
```

```{r merge data by time stamp numeric, echo=TRUE, message=FALSE, warning=FALSE}

# Set working directory
workdir_path <- "C:/Users/asd27/Desktop/Trackball calibration/Calibration_15Rot_difSpeed/R"
setwd(workdir_path)


# Merge mice by nearest time numeric

#### Rotation
LeftMouse1_Rotation <- read.csv("LeftMouse1_Rotation.csv", header = TRUE)
RightMouse2_Rotation <- read.csv("RightMouse2_Rotation.csv", header = TRUE)

## convert to data.table by reference
require(data.table)
setDT(LeftMouse1_Rotation) 
setDT(RightMouse2_Rotation)      

setkey(LeftMouse1_Rotation, Time_normalized_seconds)    ## set the column to perform the join on
setkey(RightMouse2_Rotation, Time_normalized_seconds)    ## same as above

merged_Rotation <- LeftMouse1_Rotation[RightMouse2_Rotation, roll='nearest']

# Add time difference between frame i and the next; this will correspond to the angular velocity in frame i
# So between frame i and i+1 the velocity was i

merged_Rotation <- merged_Rotation %>% mutate(Time_difference = 0)

for (i in 1:nrow(merged_Rotation)){
  merged_Rotation$Time_difference[i] = merged_Rotation$Time_normalized_seconds[i+1]-merged_Rotation$Time_normalized_seconds[i]
}

merged_Rotation <- merged_Rotation %>% 
  select(c(-X, -i.X, Time, -i.Time)) %>%
  mutate(LeftMouse1_x = as.numeric(LeftMouse1_x),
         RightMouse2_x = as.numeric(RightMouse2_x),
         Rotation_linear_displacement = -(LeftMouse1_x + RightMouse2_x)/2,
         Angular_displacement = Rotation_linear_displacement/ball_rad * 180/pi,
         Rotation_linear_velocity = Rotation_linear_displacement * Time_difference,
         Angular_velocity = Angular_displacement * Time_difference,
         Forward_displacement = sqrt(LeftMouse1_y^2 + RightMouse2_y^2),
         Forward_velocity = Forward_displacement / Time_difference,
        # Translation_angle = rad2deg(atan(RightMouse2_y/LeftMouse1_y)),
         Mice_x_error = LeftMouse1_x - RightMouse2_x)

# Cumulative angular distance (cumulative heading)
merged_Rotation <- merged_Rotation %>% mutate(Cumulative_angular_displacement = 0)

for (i in 2:nrow(merged_Rotation)){
  merged_Rotation$Cumulative_angular_displacement[i] <- merged_Rotation$Angular_displacement[i] + merged_Rotation$Cumulative_angular_displacement[i-1]
  merged_Rotation$Cumulative_forward_displacement[i] <- merged_Rotation$Forward_displacement[i] + merged_Rotation$Cumulative_forward_displacement[i-1]
}
                          


### Translation forwards
LeftMouse1_TranslationForwards <- read.csv("LeftMouse1_TranslationForwards.csv", header = TRUE)
RightMouse2_TranslationForwards <- read.csv("RightMouse2_TranslationForwards.csv", header = TRUE)

## convert to data.table by reference
require(data.table)
setDT(LeftMouse1_TranslationForwards) 
setDT(RightMouse2_TranslationForwards)      

setkey(LeftMouse1_TranslationForwards, Time_normalized_seconds)    ## set the column to perform the join on
setkey(RightMouse2_TranslationForwards, Time_normalized_seconds)    ## same as above

merged_TranslationForwards <- LeftMouse1_TranslationForwards[RightMouse2_TranslationForwards, roll='nearest']

# Add time difference between frame i and the next; this will correspond to the angular velocity in frame i
# So between frame i and i+1 the velocity was i

merged_TranslationForwards <- merged_TranslationForwards %>% mutate(Time_difference = 0)

for (i in 1:nrow(merged_TranslationForwards)){
  merged_TranslationForwards$Time_difference[i] = merged_TranslationForwards$Time_normalized_seconds[i+1]-merged_TranslationForwards$Time_normalized_seconds[i]
}

merged_TranslationForwards <- merged_TranslationForwards %>% 
  select(c(-X, -i.X, Time, -i.Time)) %>%
  mutate(LeftMouse1_x = as.numeric(LeftMouse1_x),
         RightMouse2_x = as.numeric(RightMouse2_x),
         Rotation_linear_displacement = -(LeftMouse1_x + RightMouse2_x)/2,
         Angular_displacement = Rotation_linear_displacement/ball_rad * 180/pi,
         Rotation_linear_velocity = Rotation_linear_displacement * Time_difference,
         Angular_velocity = Angular_displacement * Time_difference,
         Forward_displacement = sqrt(LeftMouse1_y^2 + RightMouse2_y^2),
         Forward_velocity = Forward_displacement / Time_difference,
        # Translation_angle = rad2deg(atan(RightMouse2_y/LeftMouse1_y)),
         Mice_x_error = LeftMouse1_x - RightMouse2_x)

# Cumulative angular distance (cumulative heading)
merged_TranslationForwards <- merged_TranslationForwards %>% mutate(Cumulative_angular_displacement = 0)

for (i in 2:nrow(merged_TranslationForwards)){
  merged_TranslationForwards$Cumulative_angular_displacement[i] <- merged_TranslationForwards$Angular_displacement[i] + merged_TranslationForwards$Cumulative_angular_displacement[i-1]
  merged_TranslationForwards$Cumulative_forward_displacement[i] <- merged_TranslationForwards$Forward_displacement[i] + merged_TranslationForwards$Cumulative_forward_displacement[i-1]
}



#### Translation to the left (right mouse picks up)
LeftMouse1_TranslationToLeft <- read.csv("LeftMouse1_TranslationToLeft.csv", header = TRUE)
RightMouse2_TranslationToLeft <- read.csv("RightMouse2_TranslationToLeft.csv", header = TRUE)

## convert to data.table by reference
require(data.table)
setDT(LeftMouse1_TranslationToLeft) 
setDT(RightMouse2_TranslationToLeft)      

setkey(LeftMouse1_TranslationToLeft, Time_normalized_seconds)    ## set the column to perform the join on
setkey(RightMouse2_TranslationToLeft, Time_normalized_seconds)    ## same as above

merged_TranslationToLeft <- LeftMouse1_TranslationToLeft[RightMouse2_TranslationToLeft, roll='nearest']

# Add time difference between frame i and the next; this will correspond to the angular velocity in frame i
# So between frame i and i+1 the velocity was i

merged_TranslationToLeft <- merged_TranslationToLeft %>% mutate(Time_difference = 0)

for (i in 1:nrow(merged_TranslationToLeft)){
  merged_TranslationToLeft$Time_difference[i] = merged_TranslationToLeft$Time_normalized_seconds[i+1]-merged_TranslationToLeft$Time_normalized_seconds[i]
}

merged_TranslationToLeft <- merged_TranslationToLeft %>% 
  select(c(-X, -i.X, Time, -i.Time)) %>%
  mutate(LeftMouse1_x = as.numeric(LeftMouse1_x),
         RightMouse2_x = as.numeric(RightMouse2_x),
         Rotation_linear_displacement = -(LeftMouse1_x + RightMouse2_x)/2,
         Angular_displacement = Rotation_linear_displacement/ball_rad * 180/pi,
         Rotation_linear_velocity = Rotation_linear_displacement * Time_difference,
         Angular_velocity = Angular_displacement * Time_difference,
         Forward_displacement = sqrt(LeftMouse1_y^2 + RightMouse2_y^2),
         Forward_velocity = Forward_displacement / Time_difference,
        # Translation_angle = rad2deg(atan(RightMouse2_y/LeftMouse1_y)),
         Mice_x_error = LeftMouse1_x - RightMouse2_x)

# Cumulative angular distance (cumulative heading)
merged_TranslationToLeft <- merged_TranslationToLeft %>% mutate(Cumulative_angular_displacement = 0)

for (i in 2:nrow(merged_TranslationToLeft)){
  merged_TranslationToLeft$Cumulative_angular_displacement[i] <- merged_TranslationToLeft$Angular_displacement[i] + merged_TranslationToLeft$Cumulative_angular_displacement[i-1]
  merged_TranslationToLeft$Cumulative_forward_displacement[i] <- merged_TranslationToLeft$Forward_displacement[i] + merged_TranslationToLeft$Cumulative_forward_displacement[i-1]
}



### Translation to the right (left mouse picks up)
LeftMouse1_TranslationToRight <- read.csv("LeftMouse1_TranslationToRight.csv", header = TRUE)
RightMouse2_TranslationToRight <- read.csv("RightMouse2_TranslationToRight.csv", header = TRUE)

## convert to data.table by reference
require(data.table)
setDT(LeftMouse1_TranslationToRight) 
setDT(RightMouse2_TranslationToRight)      

setkey(LeftMouse1_TranslationToRight, Time_normalized_seconds)    ## set the column to perform the join on
setkey(RightMouse2_TranslationToRight, Time_normalized_seconds)    ## same as above

merged_TranslationToRight <- LeftMouse1_TranslationToRight[RightMouse2_TranslationToRight, roll='nearest']

# Add time difference between frame i and the next; this will correspond to the angular velocity in frame i
# So between frame i and i+1 the velocity was i

merged_TranslationToRight <- merged_TranslationToRight %>% mutate(Time_difference = 0)

for (i in 1:nrow(merged_TranslationToRight)){
  merged_TranslationToRight$Time_difference[i] = merged_TranslationToRight$Time_normalized_seconds[i+1]-merged_TranslationToRight$Time_normalized_seconds[i]
}

merged_TranslationToRight <- merged_TranslationToRight %>% 
  select(c(-X, -i.X, Time, -i.Time)) %>%
  mutate(LeftMouse1_x = as.numeric(LeftMouse1_x),
         RightMouse2_x = as.numeric(RightMouse2_x),
         Rotation_linear_displacement = -(LeftMouse1_x + RightMouse2_x)/2,
         Angular_displacement = Rotation_linear_displacement/ball_rad * 180/pi,
         Rotation_linear_velocity = Rotation_linear_displacement * Time_difference,
         Angular_velocity = Angular_displacement * Time_difference,
         Forward_displacement = sqrt(LeftMouse1_y^2 + RightMouse2_y^2),
         Forward_velocity = Forward_displacement / Time_difference,
        # Translation_angle = rad2deg(atan(RightMouse2_y/LeftMouse1_y)),
         Mice_x_error = LeftMouse1_x - RightMouse2_x)

# Cumulative angular distance (cumulative heading)
merged_TranslationToRight <- merged_TranslationToRight %>% mutate(Cumulative_angular_displacement = 0)

for (i in 2:nrow(merged_TranslationToRight)){
  merged_TranslationToRight$Cumulative_angular_displacement[i] <- merged_TranslationToRight$Angular_displacement[i] + merged_TranslationToRight$Cumulative_angular_displacement[i-1]
  merged_TranslationToRight$Cumulative_forward_displacement[i] <- merged_TranslationToRight$Forward_displacement[i] + merged_TranslationToRight$Cumulative_forward_displacement[i-1]
}


```


## Calibration factor

The calibration factor was calculated by dividing the real distance moved, which corresponded to 15 times the perimeter of the ball at the equator, by the mouse recorded total distance (x displacement and y displacement).


```{r calibration factors, echo=TRUE, message=FALSE, warning=FALSE}


# Calibration factor for rotation
rotation_linear_displacement_recorded <- sum(merged_Rotation$Rotation_linear_displacement[1:nrow(merged_Rotation)-1])
calibration_factor_rotation <- abs(real_distance/rotation_linear_displacement_recorded)


# Calibration factor for translation forwards
translation_forwards_distance_recorded <- sum(merged_TranslationForwards$Forward_displacement[1:nrow(merged_TranslationForwards)-1])
calibration_factor_translation_forwards <- real_distance/translation_forwards_distance_recorded


# Calibration factor for translation to left
translation_toleft_distance_recorded <- sum(merged_TranslationToLeft$Forward_displacement[1:nrow(merged_TranslationToLeft)-1])
calibration_factor_translation_toleft <- real_distance/translation_toleft_distance_recorded


# Calibration factor for translation to right
translation_toright_distance_recorded <- sum(merged_TranslationToRight$Forward_displacement[1:nrow(merged_TranslationToRight)-1])
calibration_factor_translation_toright <- real_distance/translation_toright_distance_recorded


calibration_table <- data.table(Direction = c("Rotation", "Translation forwards", "Translation to left", "Translation to right"), Calibration_factor = c(calibration_factor_rotation, calibration_factor_translation_forwards, calibration_factor_translation_toleft, calibration_factor_translation_toright))

calibration_factor_mean <- mean(calibration_table$Calibration_factor)
calibration_factor_sd <- sd(calibration_table$Calibration_factor)

table1 <- flextable(calibration_table)
table1 <- fontsize(table1, part = "body", size = 8)
table1 <- colformat_double(x = table1)
table1

```

**Table 1: Calibration factors for each direction.** Calibration factors were very similar between the four conditions.


The mean calibration factor was `r calibration_factor_mean` +/- `r calibration_factor_sd`.

# Error between mice readings

Because x velocity of each mouse should be the same, the error between mice readings was calculated as the difference between the x velocity of one and the other. This was calculated for each direction.

```{r error between x mice histograms, echo=TRUE, message=FALSE, warning=FALSE}

# Histogram of error between mice - rotation
hist_error_rotation <- ggplot(merged_Rotation, aes(x = Mice_x_error))+
  geom_histogram() +
  scale_y_continuous(expand = c(0,0)) +
  ylab("N frames rotation") +
  theme


# Histogram of error between mice - translation forwards
hist_error_translationforwards <- ggplot(merged_TranslationForwards, aes(x = Mice_x_error))+
  geom_histogram() +
  scale_y_continuous(expand = c(0,0)) +
  ylab("N frames translation forwards") +
  theme


# Histogram of error between mice - translation to the left
hist_error_translationtoleft <- ggplot(merged_TranslationToLeft, aes(x = Mice_x_error))+
  geom_histogram() +
  scale_y_continuous(expand = c(0,0)) +
  ylab("N frames translation left") +
  theme


# Histogram of error between mice - translation to the right
hist_error_translationtoright <- ggplot(merged_TranslationToRight, aes(x = Mice_x_error))+
  geom_histogram() +
  scale_y_continuous(expand = c(0,0)) +
  ylab("N frames translation right") +
  theme

ggarrange(hist_error_rotation, hist_error_translationforwards, 
          hist_error_translationtoleft, hist_error_translationtoright,
          ncol = 2, nrow = 2)
```

**Figure 1: Histograms of the error between the two mice x velocities.** A) Rotation has the largest errors between mice, as it also has the largest x values. B) Translation forwards, C) translation to left and D) translation to right have much lower error. In all cases, error is roughly centered around zero.

**Note: what cut-off error between mice to use for excluding frames?** 


```{r error exclusion, echo=FALSE, message=FALSE, warning=FALSE}

### Exclusion of frames with large error between mice

#Frames with errors in the rotation data were excluded, using a cut-off value from 1 to the highest error. The cut-off value chosen was the one giving the smallest difference between the new calibration factor and the mean translation calibration factor (between the three translation types).


#**Table 2: Cut-off error exclusion for rotation data.** Cut-off value, corresponding calibration factor and difference between that and the mean calibration factor of translation data. The best cut-off value was 12.


# Rotation

#error_file <- matrix(ncol = 4, nrow = max(merged_Rotation$Mice_x_error))


# error exclusion and calibration factor

#for (i in 1:max(merged_Rotation$Mice_x_error)){
  
#  file <- merged_Rotation %>% filter(Mice_x_error < i & Mice_x_error > -i)
  
#  linear_distance_recorded_i <- sum(file$Linear_distance[1:nrow(file)-1])
#  calibration_factor_rotation_i <- real_distance/linear_distance_recorded_i
#  calibration_factor_dif_i <- calibration_factor_rotation_i - calibration_factor_translation_mean
  
#  error_file[i,1] <- i
#  error_file[i,2] <- calibration_factor_rotation_i
#  error_file[i,3] <- calibration_factor_dif_i
#  error_file[i,4] <- nrow(file)/nrow(merged_Rotation)

#}

#error_file <- as.matrix(error_file)
#colnames(error_file) <- c("error_cur-off", "calibration_factor", "calibration_factor_dif", "number_frames_proportion")
#error_file <- data.frame(error_file)

#table2 <- flextable(error_file)
#table2 <- fontsize(table2, part = "body", size = 8)
#table2

```


```{r angle histograms, echo=FALSE, message=FALSE, warning=FALSE}

## Translation angle

#The translation angle was calculated for each translation direction, by taking the y velocity from one mouse (the left) as x and the y velocity from the other mouse as y and calculating the arctangent between the two sides. It was normalized to the angle that would correspond to walking forwards (between the two mice), by subtracting 45 degrees.


# Histogram of angles translation forwards
#hist_angle_translationforwards <- ggplot(merged_TranslationForwards, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
#  theme


# Histogram of angles translation to the left
#hist_angle_translationtoleft <- ggplot(merged_TranslationToLeft, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation left") +
#  theme


# Histogram of angles translation to the right
#hist_angle_translationtoright <- ggplot(merged_TranslationToRight, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation right") +
#  theme


#ggarrange( hist_angle_translationforwards, hist_angle_translationtoleft, hist_angle_translationtoright,
#          ncol = 3, nrow = 1)


#**Figure 2: Translation angle.** A) Translation angle of forwards movement, centered around zero but showing large errors, particularly at -45 and 45 degrees. These correspond to frames in which one mouse showed picked a y velocity larger than zero and the other mouse did not. B) Translation to left and C) translation to right had lower errors and the translation angle was centered around 45 and -45 degrees, respectively.


```








```{r test data gw63, echo=FALSE, message=FALSE, warning=FALSE}
# Test

# Set working directory
workdir_path <- "C:/Users/asd27/Desktop/Trackball calibration/Calibration_15Rot_difSpeed/R"
setwd(workdir_path)

# import file
merged_QS_GW61 <- read.csv("Merged_COM_LED_2021_07_04_TBQS_GW61.csv", header = TRUE)


# Add time difference between frame i and the next; this will correspond to the angular velocity in frame i
# So between frame i and i+1 the velocity was i

merged_QS_GW61 <- merged_QS_GW61 %>% mutate(Time_difference = 0)

for (i in 1:nrow(merged_QS_GW61)){
  merged_QS_GW61$Time_difference[i] = merged_QS_GW61$Time_normalized[i+1]-merged_QS_GW61$Time_normalized[i]
}

merged_QS_GW61 <- merged_QS_GW61 %>% 
  mutate(LeftMouse1_x = as.numeric(LeftMouse1_x),
         RightMouse2_x = as.numeric(RightMouse2_x),
         Rotation_linear_displacement = -(LeftMouse1_x + RightMouse2_x)/2,
         Angular_displacement = Rotation_linear_displacement/ball_rad * 180/pi,
         Rotation_linear_velocity = Rotation_linear_displacement * Time_difference,
         Angular_velocity = Angular_displacement * Time_difference,
         Forward_displacement = sqrt(LeftMouse1_y^2 + RightMouse2_y^2),
         Forward_velocity = Forward_displacement / Time_difference,
         Translation_angle = rad2deg(atan(RightMouse2_y/LeftMouse1_y))-45,
         Mice_x_error = LeftMouse1_x - RightMouse2_x)

# Cumulative angular distance (cumulative heading)
merged_QS_GW61 <- merged_QS_GW61 %>% mutate(Cumulative_angular_displacement = 0,
                                            Cumulative_forward_displacement = 0)

for (i in 2:nrow(merged_QS_GW61)){
  merged_QS_GW61$Cumulative_angular_displacement[i] <- merged_QS_GW61$Angular_displacement[i] + merged_QS_GW61$Cumulative_angular_displacement[i-1]
  merged_QS_GW61$Cumulative_forward_displacement[i] <- merged_QS_GW61$Forward_displacement[i] + merged_QS_GW61$Cumulative_forward_displacement[i-1]
}

```


```{r error between x mice histogram - Test GW60, echo=FALSE, message=FALSE, warning=FALSE}

# Histogram of error between mice - rotation
ggplot(merged_QS_GW62, aes(x = Mice_x_error))+
  geom_histogram() +
  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames rotation") +
  theme

```



```{r rotation velocity and translation angle - Test GW60, echo=FALSE, message=FALSE, warning=FALSE}

# Histogram of angles translation forwards
#translation_angle_test_plot <- ggplot(merged_QS_GW61, aes(x = Time_normalized, y = Translation_angle))+
#  geom_point() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
#  theme


ggplot(merged_QS_GW62, aes(x = Time_normalized, y = Angular_displacement))+
  geom_point() +
  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
  theme

ggplot(merged_QS_GW62, aes(x = Time_normalized, y = Forward_displacement))+
  geom_point() +
  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
  theme

ggplot(merged_QS_GW62, aes(x = Time_normalized, y = Cumulative_angular_displacement))+
  geom_point() +
  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
  theme

ggplot(merged_QS_GW62, aes(x = Time_normalized, y = Cumulative_forward_displacement))+
  geom_point() +
  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
  theme



```



```{r angle error exclusion, echo=FALSE, message=FALSE, warning=FALSE}

### EXTRAS

## Exclusion of frames on translation with angles >= 45 from correct 


# Translation Forwards

# New file
#merged_TranslationForwards_new <- merged_TranslationForwards %>% filter(Translation_angle < 45 & Translation_angle > -45)

# New calibration factor
#translation_forwards_distance_recorded_new <- sum(merged_TranslationForwards_new$Translation_distance[1:nrow(merged_TranslationForwards_new)-1])
#calibration_factor_translation_forwards_new <- real_distance/translation_forwards_distance_recorded_new

# New histogram of angles
#hist_angle_translationforwards_new <- ggplot(merged_TranslationForwards_new, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
#  theme


# Translation to left

# New file
#merged_TranslationToLeft_new <- merged_TranslationToLeft %>% filter(Translation_angle < 45+45 & Translation_angle > 45-45)

# New calibration factor
#translation_toleft_distance_recorded_new <- sum(merged_TranslationToLeft_new$Translation_distance[1:nrow(merged_TranslationToLeft_new)-1])
#calibration_factor_translation_toleft_new <- real_distance/translation_toleft_distance_recorded_new

# New histogram of angles
#hist_angle_translationforwards_new <- ggplot(merged_TranslationToLeft_new, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
#  theme

```


```{r error exclusion new files, echo=FALSE, message=FALSE, warning=FALSE}

# Rotation
#merged_Rotation_new <- merged_Rotation %>% filter(Mice_x_error < 12 & Mice_x_error > -12)

# Translation forward
#merged_TranslationForwards_new <- merged_TranslationForwards %>% filter(Mice_x_error < 12 & Mice_x_error > -12)

# Translation to left
#merged_TranslationToLeft_new <- merged_TranslationToLeft %>% filter(Mice_x_error < 12 & Mice_x_error > -12)

# Translation to right
#merged_TranslationToRight_new <- merged_TranslationToRight %>% filter(Mice_x_error < 12 & Mice_x_error > -12)


```


```{r new angle histograms, echo=FALSE, message=FALSE, warning=FALSE}


# Histogram of angles translation forwards
#hist_angle_translationforwards_new <- ggplot(merged_TranslationForwards_new, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation forwards") +
#  theme


# Histogram of angles translation to the left
#hist_angle_translationtoleft_new <- ggplot(merged_TranslationToLeft_new, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation left") +
#  theme


# Histogram of angles translation to the right
#hist_angle_translationtoright_new <- ggplot(merged_TranslationToRight_new, aes(x = Translation_angle))+
#  geom_histogram() +
#  scale_y_continuous(expand = c(0,0)) +
#  ylab("N frames translation right") +
#  theme


#ggarrange(hist_angle_translationforwards_new, hist_angle_translationtoleft_new, hist_angle_translationtoright,
#          ncol = 3, nrow = 1)


```